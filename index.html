<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spyfall - Multiplayer Game</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          sans-serif;
        background: #2c3e50;
        min-height: 100vh;
        padding: 20px;
        color: #333;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        padding: 30px;
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-size: 32px;
        text-align: center;
      }

      h2 {
        color: #34495e;
        font-size: 20px;
        margin-bottom: 15px;
      }

      .subtitle {
        text-align: center;
        color: #7f8c8d;
        margin-bottom: 30px;
      }

      input[type="text"],
      input[type="number"] {
        width: 100%;
        padding: 14px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        margin-bottom: 15px;
        transition: border-color 0.3s;
      }

      input[type="text"]:focus,
      input[type="number"]:focus {
        outline: none;
        border-color: #3498db;
      }

      button {
        width: 100%;
        padding: 14px;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s;
        margin-bottom: 10px;
      }

      button:hover:not(:disabled) {
        background: #2980b9;
      }

      button:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
      }

      button.secondary {
        background: #95a5a6;
      }

      button.secondary:hover:not(:disabled) {
        background: #7f8c8d;
      }

      button.danger {
        background: #e74c3c;
      }

      button.danger:hover:not(:disabled) {
        background: #c0392b;
      }

      button.success {
        background: #27ae60;
      }

      button.success:hover:not(:disabled) {
        background: #229954;
      }

      .hidden {
        display: none !important;
      }

      /* Room list */
      .room-list {
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 20px;
      }

      .room-item {
        padding: 15px;
        background: #ecf0f1;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .room-info h3 {
        font-size: 18px;
        color: #2c3e50;
        margin-bottom: 5px;
      }

      .room-info p {
        font-size: 14px;
        color: #7f8c8d;
      }

      .room-item button {
        width: auto;
        padding: 10px 20px;
        margin: 0;
      }

      /* Player list */
      .player-list {
        background: #ecf0f1;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .player {
        padding: 12px;
        background: white;
        border-radius: 6px;
        margin-bottom: 8px;
        font-weight: 500;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .player.host::after {
        content: "üëë";
        margin-left: 10px;
      }

      /* Role card */
      .role-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
      }

      .role-card.spy {
        background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
      }

      .role-card h2 {
        color: white;
        font-size: 28px;
        margin-bottom: 10px;
      }

      .role-card p {
        font-size: 20px;
        margin: 10px 0;
      }

      /* Location grid */
      .locations-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
        margin-bottom: 20px;
      }

      .location {
        padding: 12px;
        background: #ecf0f1;
        border-radius: 8px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s;
        font-size: 14px;
        font-weight: 500;
      }

      .location:hover {
        background: #d5dbdb;
      }

      .location.crossed {
        background: #e74c3c;
        color: white;
        text-decoration: line-through;
        opacity: 0.6;
      }

      /* Timer */
      .timer-section {
        background: #34495e;
        color: white;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        margin-bottom: 20px;
      }

      .timer-display {
        font-size: 48px;
        font-weight: bold;
        margin-bottom: 15px;
        font-family: "Courier New", monospace;
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }

      .timer-controls button {
        flex: 1;
      }

      /* Settings */
      .settings-group {
        margin-bottom: 20px;
      }

      .settings-group label {
        display: block;
        font-weight: 500;
        margin-bottom: 8px;
        color: #2c3e50;
      }

      /* Status messages */
      .status-message {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 500;
      }

      .status-message.info {
        background: #d6eaf8;
        color: #1f618d;
      }

      .status-message.success {
        background: #d5f4e6;
        color: #0e6655;
      }

      .status-message.warning {
        background: #fcf3cf;
        color: #7d6608;
      }

      /* Chat */
      .chat-container {
        background: #ecf0f1;
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .chat-messages {
        max-height: 300px;
        overflow-y: auto;
        margin-bottom: 15px;
        padding: 10px;
        background: white;
        border-radius: 8px;
      }

      .chat-message {
        margin-bottom: 12px;
        padding: 10px;
        border-radius: 8px;
        background: #f8f9fa;
      }

      .chat-message.question {
        background: #d6eaf8;
        border-left: 4px solid #3498db;
      }

      .chat-message.answer {
        background: #d5f4e6;
        border-left: 4px solid #27ae60;
      }

      .chat-message .sender {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 4px;
      }

      .chat-message .target {
        color: #e74c3c;
        font-weight: 600;
      }

      .chat-message .text {
        color: #34495e;
      }

      .chat-message.waiting {
        background: #fcf3cf;
        border-left: 4px solid #f39c12;
        font-style: italic;
        text-align: center;
      }

      .chat-input-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .chat-input-row {
        display: flex;
        gap: 10px;
      }

      .chat-input-group select,
      .chat-input-group input {
        margin-bottom: 0;
      }

      .chat-input-group select {
        flex: 1;
      }

      .chat-input-row button {
        width: auto;
        padding: 14px 20px;
        margin: 0;
      }

      /* Online users counter */
      .online-counter {
        position: absolute;
        top: 20px;
        right: 20px;
        background: #27ae60;
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .online-counter::before {
        content: "‚óè";
        font-size: 12px;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      @media (max-width: 600px) {
        .online-counter {
          top: 10px;
          right: 10px;
          font-size: 12px;
          padding: 6px 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="online-counter" id="onlineCounter">
        <span id="onlineCount">0</span> online
      </div>

      <!-- HOME SCREEN -->
      <div id="homeScreen">
        <h1>üïµÔ∏è Spyfall</h1>
        <p class="subtitle">Find the spy among you!</p>

        <div class="settings-group">
          <label for="usernameInput">Your Name</label>
          <input type="text" id="usernameInput" placeholder="Enter your name" />
        </div>

        <button id="createRoomBtn" disabled>Create New Room</button>

        <div style="text-align: center; margin: 20px 0; color: #7f8c8d">OR</div>

        <h2>Join Existing Room</h2>
        <div id="roomList" class="room-list">
          <div class="status-message info">Loading rooms...</div>
        </div>
      </div>

      <!-- LOBBY SCREEN -->
      <div id="lobbyScreen" class="hidden">
        <h1>üïµÔ∏è Spyfall</h1>
        <p class="subtitle" id="roomName">Room Name</p>

        <h2>Players in Lobby</h2>
        <div id="playerList" class="player-list"></div>

        <div class="settings-group">
          <label for="gameDuration">Game Duration (minutes)</label>
          <input type="number" id="gameDuration" value="8" min="1" max="30" />
        </div>
        <button id="startGameBtn" class="success">Start Game</button>

        <button id="leaveLobbyBtn" class="danger">Leave Room</button>
      </div>

      <!-- GAME SCREEN -->
      <div id="gameScreen" class="hidden">
        <h1>üïµÔ∏è Spyfall</h1>

        <!-- Role Card -->
        <div id="roleCard" class="role-card"></div>

        <!-- Players -->
        <h2>Players</h2>
        <div id="gamePlayers" class="player-list"></div>

        <!-- Chat -->
        <div class="chat-container">
          <h2>Chat & Questions</h2>
          <div id="chatMessages" class="chat-messages"></div>
          <div class="chat-input-group">
            <select id="targetPlayer">
              <option value="">Select player to ask...</option>
            </select>
            <div class="chat-input-row">
              <input
                type="text"
                id="chatInput"
                placeholder="Type your question..."
              />
              <button id="sendQuestionBtn" class="success">Ask</button>
            </div>
          </div>
        </div>

        <!-- Timer -->
        <div class="timer-section">
          <div class="timer-display" id="timerDisplay">8:00</div>
          <div class="timer-controls">
            <button id="startTimerBtn" class="success">Start Timer</button>
            <button id="stopTimerBtn" class="secondary">Stop Timer</button>
          </div>
        </div>

        <!-- Locations -->
        <h2>Game Locations (<span id="locationCount">27</span>)</h2>
        <div id="locationsGrid" class="locations-grid"></div>

        <button id="endGameBtn" class="danger">End Game</button>
      </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <!-- Game Data -->
    <script src="game-data.js"></script>

    <script>
      // Firebase Configuration
      const firebaseConfig = {
        apiKey: "AIzaSyDBQWubzgtbljvlq_7Nfmturg3_4Nhauh0",
        authDomain: "spygame-fa5d0.firebaseapp.com",
        databaseURL: "https://spygame-fa5d0-default-rtdb.firebaseio.com",
        projectId: "spygame-fa5d0",
        storageBucket: "spygame-fa5d0.firebasestorage.app",
        messagingSenderId: "1031471679689",
        appId: "1:1031471679689:web:e61361fe2f2a2079efa518",
      };

      firebase.initializeApp(firebaseConfig);
      const database = firebase.database();
      const roomsRef = database.ref("rooms");
      const onlineUsersRef = database.ref("onlineUsers");

      // Global state
      let peer = null;
      let myPeerId = null;
      let myUsername = null;
      let currentRoomId = null;
      let isHost = false;
      let connections = {};
      let timerInterval = null;
      let timerSeconds = 0;
      let gameState = null;
      let currentTurn = null;
      let allPlayers = {};

      // DOM elements
      const homeScreen = document.getElementById("homeScreen");
      const lobbyScreen = document.getElementById("lobbyScreen");
      const gameScreen = document.getElementById("gameScreen");
      const usernameInput = document.getElementById("usernameInput");
      const createRoomBtn = document.getElementById("createRoomBtn");
      const roomList = document.getElementById("roomList");
      const playerList = document.getElementById("playerList");
      const gamePlayers = document.getElementById("gamePlayers");
      const startGameBtn = document.getElementById("startGameBtn");
      const leaveLobbyBtn = document.getElementById("leaveLobbyBtn");
      const gameDuration = document.getElementById("gameDuration");
      const roleCard = document.getElementById("roleCard");
      const locationsGrid = document.getElementById("locationsGrid");
      const locationCount = document.getElementById("locationCount");
      const timerDisplay = document.getElementById("timerDisplay");
      const startTimerBtn = document.getElementById("startTimerBtn");
      const stopTimerBtn = document.getElementById("stopTimerBtn");
      const endGameBtn = document.getElementById("endGameBtn");
      const roomName = document.getElementById("roomName");
      const chatMessages = document.getElementById("chatMessages");
      const chatInput = document.getElementById("chatInput");
      const targetPlayer = document.getElementById("targetPlayer");
      const sendQuestionBtn = document.getElementById("sendQuestionBtn");
      const onlineCount = document.getElementById("onlineCount");

      // Track online users
      function trackOnlinePresence() {
        if (!myPeerId) return;

        const myConnectionRef = onlineUsersRef.child(myPeerId);
        myConnectionRef.set(true);
        myConnectionRef.onDisconnect().remove();

        // Listen for online users count
        onlineUsersRef.on("value", (snapshot) => {
          const users = snapshot.val();
          const count = users ? Object.keys(users).length : 0;
          onlineCount.textContent = count;
        });
      }

      // Initialize PeerJS
      function initPeer() {
        peer = new Peer();

        peer.on("open", (id) => {
          console.log("My peer ID:", id);
          myPeerId = id;
          createRoomBtn.disabled = false;
          loadRooms();
          trackOnlinePresence();
        });

        peer.on("connection", (conn) => {
          console.log("Incoming connection from:", conn.peer);
          setupConnection(conn);
        });

        peer.on("error", (err) => {
          console.error("Peer error:", err);
          alert("Connection error: " + err.message);
        });
      }

      // Setup peer connection
      function setupConnection(conn) {
        connections[conn.peer] = conn;

        conn.on("open", () => {
          console.log("Connection established with:", conn.peer);
        });

        conn.on("data", (data) => {
          console.log("Received data:", data);
          handlePeerMessage(data);
        });

        conn.on("close", () => {
          console.log("Connection closed with:", conn.peer);
          delete connections[conn.peer];
        });
      }

      // Handle messages from peers
      function handlePeerMessage(data) {
        if (data.type === "gameStart") {
          gameState = data.gameState;
          startGame();
        } else if (data.type === "gameEnd") {
          endGame();
        } else if (data.type === "timerStart") {
          startTimerSync(data.seconds);
        } else if (data.type === "timerStop") {
          stopTimer();
        } else if (data.type === "chat") {
          addChatMessage(data.message);
        }
      }

      // Send message to all peers
      function broadcastToPeers(data) {
        Object.values(connections).forEach((conn) => {
          conn.send(data);
        });
      }

      // Enable create button when username is entered
      usernameInput.addEventListener("input", () => {
        if (usernameInput.value.trim() && myPeerId) {
          createRoomBtn.disabled = false;
        } else {
          createRoomBtn.disabled = true;
        }
      });

      // Create room
      createRoomBtn.addEventListener("click", () => {
        const username = usernameInput.value.trim();
        if (!username) {
          alert("Please enter your name");
          return;
        }

        myUsername = username;
        const roomId = "room_" + Date.now();
        currentRoomId = roomId;
        isHost = true;

        const roomData = {
          name: username + "'s Room",
          hostPeerId: myPeerId,
          hostName: username,
          createdAt: Date.now(),
          players: {
            [myPeerId]: {
              name: username,
              peerId: myPeerId,
              isHost: true,
            },
          },
          gameStarted: false,
        };

        roomsRef
          .child(roomId)
          .set(roomData)
          .then(() => {
            // Set presence tracking
            const playerPresenceRef = roomsRef
              .child(roomId)
              .child("players")
              .child(myPeerId)
              .child("connected");
            playerPresenceRef.set(true);
            playerPresenceRef.onDisconnect().set(false);

            showLobby();
            watchRoom();
          })
          .catch((error) => {
            console.error("Error creating room:", error);
            alert("Failed to create room");
          });
      });

      // Load rooms
      function loadRooms() {
        roomsRef.on("value", (snapshot) => {
          const rooms = snapshot.val();

          if (!rooms || Object.keys(rooms).length === 0) {
            roomList.innerHTML =
              '<div class="status-message info">No rooms available. Create one!</div>';
            return;
          }

          let roomsHtml = "";
          Object.entries(rooms).forEach(([roomId, room]) => {
            if (!room.gameStarted) {
              const playerCount = room.players
                ? Object.keys(room.players).length
                : 0;
              roomsHtml += `
                <div class="room-item">
                  <div class="room-info">
                    <h3>${room.name}</h3>
                    <p>${playerCount} player(s)</p>
                  </div>
                  <div style="display: flex; gap: 10px;">
                    <button onclick="joinRoom('${roomId}')">Join</button>
                    <button onclick="deleteRoom('${roomId}')" class="danger" style="width: auto; padding: 10px 16px;">Delete</button>
                  </div>
                </div>
              `;
            }
          });

          roomList.innerHTML =
            roomsHtml ||
            '<div class="status-message info">No rooms available. Create one!</div>';
        });
      }

      // Delete room
      window.deleteRoom = function (roomId) {
        if (confirm("Are you sure you want to delete this room?")) {
          roomsRef
            .child(roomId)
            .remove()
            .then(() => {
              console.log("Room deleted:", roomId);
            })
            .catch((error) => {
              console.error("Error deleting room:", error);
              alert("Failed to delete room");
            });
        }
      };

      // Join room
      window.joinRoom = function (roomId) {
        const username = usernameInput.value.trim();
        if (!username) {
          alert("Please enter your name");
          return;
        }

        myUsername = username;
        currentRoomId = roomId;
        isHost = false;

        roomsRef
          .child(roomId)
          .once("value")
          .then((snapshot) => {
            const room = snapshot.val();
            if (!room) {
              alert("Room no longer exists");
              return;
            }

            // Add player to room
            roomsRef
              .child(roomId)
              .child("players")
              .child(myPeerId)
              .set({
                name: username,
                peerId: myPeerId,
                isHost: false,
                connected: true,
              })
              .then(() => {
                // Set presence tracking
                const playerPresenceRef = roomsRef
                  .child(roomId)
                  .child("players")
                  .child(myPeerId)
                  .child("connected");
                playerPresenceRef.onDisconnect().set(false);

                // Connect to all existing players in room (exclude self)
                Object.entries(room.players || {}).forEach(
                  ([peerId, player]) => {
                    if (
                      peerId !== myPeerId &&
                      player &&
                      player.peerId &&
                      !connections[peerId]
                    ) {
                      console.log("Connecting to player:", peerId, player.name);
                      const conn = peer.connect(peerId);
                      setupConnection(conn);
                    }
                  },
                );

                showLobby();
                watchRoom();
              });
          });
      };

      // Watch room for updates
      function watchRoom() {
        roomsRef.child(currentRoomId).on("value", (snapshot) => {
          const room = snapshot.val();
          if (!room) {
            alert("Room was closed");
            leaveRoom();
            return;
          }

          // Check if all players disconnected
          if (room.players) {
            const connectedPlayers = Object.values(room.players).filter(
              (p) => p.connected,
            );
            if (connectedPlayers.length === 0) {
              // Clean up empty room
              roomsRef.child(currentRoomId).remove();
              return;
            }
          }

          allPlayers = room.players || {};
          updatePlayerList(room.players);
          roomName.textContent = room.name;

          if (room.gameStarted && !gameState) {
            // Game started, load state
            gameState = room.gameState;
            currentTurn = room.currentTurn || null;
            startGame();
          }

          // Update chat if game is running
          if (gameState && room.chat) {
            displayChat(room.chat);
          }

          // Update current turn
          if (room.currentTurn) {
            currentTurn = room.currentTurn;
            updateChatUI();
          }

          // Sync timer state
          if (gameState && room.timerRunning !== undefined) {
            if (room.timerRunning && !timerInterval) {
              // Timer should be running but isn't
              const elapsed = Math.floor(
                (Date.now() - room.timerStartTime) / 1000,
              );
              const remainingSeconds = Math.max(0, room.timerSeconds - elapsed);
              startTimerSync(remainingSeconds);
            } else if (!room.timerRunning && timerInterval) {
              // Timer should be stopped but is running
              stopTimer();
            }
          }
        });
      }

      // Update player list
      function updatePlayerList(players) {
        if (!players) return;

        let html = "";
        Object.values(players).forEach((player) => {
          html += `<div class="player${player.isHost ? " host" : ""}">${player.name}</div>`;
        });

        playerList.innerHTML = html;
        gamePlayers.innerHTML = html;
      }

      // Show lobby
      function showLobby() {
        homeScreen.classList.add("hidden");
        lobbyScreen.classList.remove("hidden");
        gameScreen.classList.add("hidden");
      }

      // Leave room
      leaveLobbyBtn.addEventListener("click", () => {
        leaveRoom();
      });

      function leaveRoom() {
        if (currentRoomId) {
          // Mark player as disconnected
          roomsRef
            .child(currentRoomId)
            .child("players")
            .child(myPeerId)
            .child("connected")
            .set(false);

          roomsRef.child(currentRoomId).off();
        }

        Object.values(connections).forEach((conn) => conn.close());
        connections = {};

        currentRoomId = null;
        isHost = false;
        gameState = null;
        currentTurn = null;

        homeScreen.classList.remove("hidden");
        lobbyScreen.classList.add("hidden");
        gameScreen.classList.add("hidden");
      }

      // Start game
      startGameBtn.addEventListener("click", () => {
        roomsRef
          .child(currentRoomId)
          .once("value")
          .then((snapshot) => {
            const room = snapshot.val();
            const players = Object.values(room.players);

            if (players.length < 3) {
              alert("Need at least 3 players to start!");
              return;
            }

            // Assign roles
            const location =
              GAME_LOCATIONS[Math.floor(Math.random() * GAME_LOCATIONS.length)];
            const spyIndex = Math.floor(Math.random() * players.length);

            const assignments = {};
            players.forEach((player, index) => {
              assignments[player.peerId] = {
                isSpy: index === spyIndex,
                location: index === spyIndex ? null : location.name,
                role:
                  index === spyIndex
                    ? null
                    : location.roles[index % location.roles.length],
              };
            });

            gameState = {
              location: location.name,
              assignments: assignments,
              duration: parseInt(gameDuration.value) * 60,
              startTime: Date.now(),
            };

            // Update Firebase
            roomsRef.child(currentRoomId).update({
              gameStarted: true,
              gameState: gameState,
            });

            // Broadcast to peers
            broadcastToPeers({
              type: "gameStart",
              gameState: gameState,
            });

            startGame();
          });
      });

      // Start game screen
      function startGame() {
        homeScreen.classList.add("hidden");
        lobbyScreen.classList.add("hidden");
        gameScreen.classList.remove("hidden");

        // Show role
        const assignment = gameState.assignments[myPeerId];
        if (assignment.isSpy) {
          roleCard.className = "role-card spy";
          roleCard.innerHTML =
            "<h2>üïµÔ∏è You are the SPY!</h2><p>Find out the location without revealing yourself!</p>";
        } else {
          roleCard.className = "role-card";
          roleCard.innerHTML = `<h2>üìç Location: ${assignment.location}</h2><p>Role: ${assignment.role}</p>`;
        }

        // Show all locations
        locationsGrid.innerHTML = "";
        GAME_LOCATIONS.forEach((loc) => {
          const div = document.createElement("div");
          div.className = "location";
          div.textContent = loc.name;
          div.onclick = () => toggleLocation(div);
          locationsGrid.appendChild(div);
        });

        // Setup timer
        timerSeconds = gameState.duration;
        updateTimerDisplay();

        // Populate player dropdown for chat
        updateChatUI();
      }

      // Toggle location crossed off
      function toggleLocation(element) {
        element.classList.toggle("crossed");
        const crossed = document.querySelectorAll(".location.crossed").length;
        locationCount.textContent = GAME_LOCATIONS.length - crossed;
      }

      // Timer functions
      startTimerBtn.addEventListener("click", () => {
        if (!timerInterval) {
          // Update Firebase with timer state
          roomsRef.child(currentRoomId).update({
            timerRunning: true,
            timerSeconds: timerSeconds,
            timerStartTime: Date.now(),
          });

          // Broadcast to peers (backup)
          broadcastToPeers({
            type: "timerStart",
            seconds: timerSeconds,
          });

          startTimerSync(timerSeconds);
        }
      });

      stopTimerBtn.addEventListener("click", () => {
        // Update Firebase
        roomsRef.child(currentRoomId).update({
          timerRunning: false,
          timerSeconds: timerSeconds,
        });

        // Broadcast to peers (backup)
        broadcastToPeers({ type: "timerStop" });

        stopTimer();
      });

      function startTimerSync(seconds) {
        if (timerInterval) return;

        timerSeconds = seconds;
        updateTimerDisplay();

        timerInterval = setInterval(() => {
          timerSeconds--;
          updateTimerDisplay();
          if (timerSeconds <= 0) {
            stopTimer();
            alert("Time is up!");
          }
        }, 1000);
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      function updateTimerDisplay() {
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
      }

      // Chat functions
      sendQuestionBtn.addEventListener("click", () => {
        const target = targetPlayer.value;
        const question = chatInput.value.trim();

        if (!target) {
          alert("Please select a player to ask");
          return;
        }

        if (!question) {
          alert("Please type a question");
          return;
        }

        if (
          currentTurn &&
          currentTurn.waitingFor &&
          currentTurn.waitingFor !== myPeerId
        ) {
          alert(
            "Wait for " +
              allPlayers[currentTurn.waitingFor].name +
              " to answer first!",
          );
          return;
        }

        const message = {
          id: Date.now(),
          type: "question",
          from: myPeerId,
          fromName: myUsername,
          to: target,
          toName: allPlayers[target].name,
          text: question,
          timestamp: Date.now(),
        };

        // Add to Firebase
        roomsRef.child(currentRoomId).child("chat").push(message);

        // Set turn to wait for answer
        roomsRef.child(currentRoomId).child("currentTurn").set({
          asker: myPeerId,
          waitingFor: target,
          questionId: message.id,
        });

        // Broadcast to peers
        broadcastToPeers({
          type: "chat",
          message: message,
        });

        chatInput.value = "";
      });

      chatInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          sendQuestionBtn.click();
        }
      });

      function displayChat(chat) {
        if (!chat) return;

        const messages = Object.values(chat).sort(
          (a, b) => a.timestamp - b.timestamp,
        );
        chatMessages.innerHTML = "";

        messages.forEach((msg) => {
          addChatMessage(msg, false);
        });

        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function addChatMessage(msg, scrollToBottom = true) {
        const div = document.createElement("div");
        div.className = `chat-message ${msg.type}`;

        if (msg.type === "question") {
          div.innerHTML = `
            <div class="sender">${msg.fromName}</div>
            <div class="text">asks <span class="target">${msg.toName}</span>: ${msg.text}</div>
          `;
        } else if (msg.type === "answer") {
          div.innerHTML = `
            <div class="sender">${msg.fromName}</div>
            <div class="text">answers: ${msg.text}</div>
          `;
        }

        chatMessages.appendChild(div);

        if (scrollToBottom) {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }

      function updateChatUI() {
        // Update player dropdown
        targetPlayer.innerHTML =
          '<option value="">Select player to ask...</option>';
        Object.entries(allPlayers).forEach(([peerId, player]) => {
          if (peerId !== myPeerId && player.connected) {
            targetPlayer.innerHTML += `<option value="${peerId}">${player.name}</option>`;
          }
        });

        // Show waiting message if needed
        if (currentTurn && currentTurn.waitingFor) {
          if (currentTurn.waitingFor === myPeerId) {
            // It's my turn to answer
            const waitingDiv = document.createElement("div");
            waitingDiv.className = "chat-message waiting";
            waitingDiv.innerHTML = `
              <div>It's your turn to answer!</div>
              <input type="text" id="answerInput" placeholder="Type your answer..." style="margin: 10px 0;" />
              <button onclick="sendAnswer()" class="success" style="width: 100%;">Send Answer</button>
            `;

            // Check if waiting message already exists
            const existingWaiting = chatMessages.querySelector(".waiting");
            if (existingWaiting) {
              existingWaiting.remove();
            }

            chatMessages.appendChild(waitingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        }

        // Disable/enable asking based on turn
        if (
          currentTurn &&
          currentTurn.waitingFor &&
          currentTurn.waitingFor !== myPeerId
        ) {
          sendQuestionBtn.disabled = true;
          chatInput.disabled = true;
          targetPlayer.disabled = true;
        } else {
          sendQuestionBtn.disabled = false;
          chatInput.disabled = false;
          targetPlayer.disabled = false;
        }
      }

      window.sendAnswer = function () {
        const answerInput = document.getElementById("answerInput");
        const answer = answerInput.value.trim();

        if (!answer) {
          alert("Please type an answer");
          return;
        }

        const message = {
          id: Date.now(),
          type: "answer",
          from: myPeerId,
          fromName: myUsername,
          text: answer,
          timestamp: Date.now(),
        };

        // Add to Firebase
        roomsRef.child(currentRoomId).child("chat").push(message);

        // Clear turn - now answerer can ask
        roomsRef.child(currentRoomId).child("currentTurn").set({
          asker: myPeerId,
          waitingFor: null,
          questionId: null,
        });

        // Broadcast to peers
        broadcastToPeers({
          type: "chat",
          message: message,
        });
      };

      // End game
      endGameBtn.addEventListener("click", () => {
        if (confirm("Are you sure you want to end the game?")) {
          roomsRef.child(currentRoomId).update({
            gameStarted: false,
            gameState: null,
            currentTurn: null,
            chat: null,
            timerRunning: false,
          });
          broadcastToPeers({ type: "gameEnd" });
          endGame();
        }
      });

      function endGame() {
        stopTimer();
        gameState = null;
        currentTurn = null;
        chatMessages.innerHTML = "";
        showLobby();
      }

      // Initialize
      initPeer();
    </script>
  </body>
</html>
